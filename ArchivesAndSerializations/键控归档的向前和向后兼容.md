# Forward and Backward Compatibility for Keyed Archives 键控归档的向前和向后兼容

Keyed archiving gives you plenty of flexibility to make your classes forward and backward compatible. The following sections describe some general tips on how you can implement compatibility and then some guidelines for maintaining compatibility with specific types of changes.

键控存档为您提供了足够的灵活性，使您的类向前和向后兼容。以下各节介绍了一些关于如何实现兼容性的一般技巧，以及一些维护与特定类型更改兼容性的指导原则。

## Benefits of Keyed Archiving 键控归档的益处
The principal benefit of keyed coding is that it makes it easier to be backward and forward compatible. The ability to read keyed values from the archive in any order, ignore keys you don’t need, and add new keys without disrupting older versions of the class is the foundation for implementing backward and forward compatibility with keyed coding.

键控编码的主要优点是可以更容易地向后兼容。能够以任何顺序从档案中读取键值，忽略不需要的键，并添加新的键而不中断较旧版本的类，这是实现键控编码的向前和向后兼容性的基础。

For maximum compatibility, you need to be able to do the following:

为了获得最大的兼容性，您需要能够执行以下操作：

* Read archives created by older versions of your class.
	
	读取由您的类的旧版本创建的档案。
* Create archives that can be read by older versions of your class.

	创建可以由您的类的旧版本读取的档案。
* Read archives created by future versions of your class.

	读取未来版本的类创建的档案。
* Create archives that can be read by future versions of your class.

	创建可以被您类的未来版本读取的档案。
	
The first two items provide full backward compatibility: the old and current versions of the class can read each others archives. To achieve this capability, it is essential that you know what values were encoded by all the previous versions of your class that you need to support as well as how previous versions decode themselves. If you don’t have this information, you may be able to deduce some things from existing archives and the existing implementations of the `NSCoding` methods.

前两项提供了完全的向后兼容性：类的旧版本和当前版本可以读取彼此的档案。 为了实现这个功能，至关重要的一点是，您需要知道您需要支持的所有以前版本的类的编码值以及之前的版本如何解码自己。 如果您没有这些信息，则可以从现有存档和`NSCoding`方法的现有实现中推导出一些内容。

The last two items provide full forward compatibility: the current and future versions of the class can read each others archives. To achieve this capability, you need to anticipate the types of changes you may make in the future and code your current `NSCoding` methods appropriately.

最后两项提供了完全的向前兼容性：当前和未来版本的类可以读取彼此的档案。要实现这一功能，您需要预测将来可能做出更改的类型，并适当地编写当前的`NSCoding`方法。

## General Tips on Maintaining Compatibility 保持兼容性的一般提示

To easily identify the version of the class being decoded, you can add some version info to the archive. This can be any type of information you want, not just an integer (such as the class version) as it was with non-keyed coding. You may just encode a “version” integer or string with some key or in some rare cases you may want a dictionary object full of goodies. Of course, adding some version information today presumes that you also have a plan for dealing with different versions in your `initWithCoder:` today. If not, changing the version info in the future will not do the present version of the class any good.

要轻松识别正在解码的类的版本，你可以将一些版本信息添加到存档。这可以是你想要的任何类型的信息，而不仅仅是一个整数（例如类的版本），因为它是非键控编码。你可能只是用一些键来编码一个“版本”整数或字符串，或者在一些极少数情况下，你可能想要一个字典对象充满了东西。当然，现在添加一些版本信息，假设你也有一个计划在`initWithCoder:`中处理不同版本。如果没有，将来更改版本信息将不会对目前的版本有任何好处。

Remember to keep your `NSCoding` implementations synchronized. Whenever you change how you write out an objects’ state in the class’s `encodeWithCoder:` method, you need to update your `initWithCoder:` method to understand the new keys. Because information in a keyed archive can be encoded and decoded in any order, the two `NSCoding` methods don’t need to process keys in the same sequence. Use whatever sequences is most convenient for each method.

记住要保持你的`NSCoding`实现同步。每当你改变你如何在类的`encodeWithCoder:`方法中写出一个对象的状态时，你需要更新你的`initWithCoder:`方法来理解新的键。由于键控存档中的信息可以按任意顺序编码和解码，因此两个`NSCoding`方法不需要按相同顺序处理键。使用每种方法最方便的顺序即可。

## Adding New Values to Keys 为键添加新的值

Some of the values a class encodes may have a particular set of possible values. For example, a button can be a checkbox, a radio button, a push button, and so on. In the future, your set of values may expand; you may create a button that has another type of behavior and need to have a new value for the button’s type.

一些类编码的值可能有一组特定的可能值。例如，按钮可以是复选框，单选按钮，一个按压按钮等等。将来，你的值得集合可能会扩大; 您可以创建一个具有其他类型行为的按钮，并且需要为该按钮的类型创建一个新值。

To prepare for this change in future archives, you can test whether the decoded value for the key is one of the allowed values. If it is not, you can assign a default value to it. Then, the future version of the class can just assign the new value to the old key and the current class will behave reasonably well.

为了在将来的存档中准备这个变化，你可以测试这个键解码值是否是允许值之一。 如果不是，则可以为其分配默认值。然后，类的未来版本可以将新值分配给旧的键，并且当前类将表现得相当好。

If you are making this change and a previous version did not make allowances for the change or the allowances are insufficient or unacceptable, you probably have to create a whole new key for the new state (see [Adding New Keys](#AddingNewKeys)) and make the old key obsolete (see [Removing or Retiring Keys](#RemovingorRetiringKeys)).

如果您正在进行此更改并且以前的版本没有考虑更改的余地或者余地不足或不可接受，那么您可能必须为新状态创建一个全新的键（请参阅[添加新键](#AddingNewKeys)），并使旧键过时（请参阅[删除或取消键](#RemovingorRetiringKeys)）。

## <a name="AddingNewKeys"></a>Adding New Keys 添加新键

As a class evolves, you may need to add information to the class to describe its new features. For example, a button has a label and a style. Later you may allow the button to have a custom color. You need to create a new key in the archive to hold the color data.

随着类的演变，您可能需要向类添加信息来描述其新功能。例如，一个按钮有一个标签和一个样式。之后，您可以允许按钮具有自定义颜色。您需要在存档中创建一个新的键来保存颜色数据。

Because you do not need to decode every value in a keyed archive, new keyed values are harmless to old versions of the class, as long as it is OK for them not to be initialized with such state. You can safely add as many new keys as necessary without affecting older versions; old versions automatically ignore those values.

因为不需要解码密钥存档中的每个值，所以新的密钥值对于旧版本的类是无害的，只要它们不被初始化为这样的状态即可。 您可以根据需要安全地添加尽可能多的新密钥，而不会影响旧版本; 旧版本会自动忽略这些值。

When decoding older archives, you must be prepared to handle the absence of the new key. If appropriate, you can still attempt to decode the new key and just accept the default value for the missing key (nil, 0, NSZeroPoint, and so on). The coder’s default value may not be valid for every key, however. In that case, you should detect the default value and substitute a more reasonable default value of your own. If the new key is a replacement for an older key, the appropriate substitution should come from the old key, which may require mapping the old value to one of the allowed values for the new key. If you must distinguish between the default value for a missing key and the same value for an existing key, use the NSCoder method containsValueForKey:.

If the new key is replacing an older key, you need to properly handle the obsolete key (see Removing or Retiring Keys).

## <a name="RemovingorRetiringKeys"></a>Removing or Retiring Keys 删除或取消键

As a class evolves, some information may become obsolete or replaced by a newer implementation.

Because you do not need to decode every value in a keyed archive, when decoding older archives, you can just ignore keys you no longer need. The decoding will be slightly faster, too.

When decoding future archives, you must be prepared to handle missing keys. If appropriate, you can simply accept the default decode value for the missing keys (nil, 0, NSZeroPoint, and so on). If the coder’s default value is not valid for a particular key, you should detect the default value and substitute a more reasonable default value of your own. If you must distinguish between the default value for a missing key and the same value for an existing key, use the NSCoder method containsValueForKey:. In this way, you give yourself the flexibility to stop encoding certain values later.

In cases where you need to abandon an old key for a newer one, but an old class cannot handle a missing key appropriately, you need to keep writing some value for the old key as well as the newer key. The value should be something the old class can understand and should probably be as close a simulation of the new state as possible. For example, consider a class that originally came in “vanilla”, “chocolate”, and “butter pecan” flavors and now has additional “double chocolate” and “caramel” flavors. To encode a value for the old key, you can map “double chocolate” to the value for “chocolate” in the old class, but you may have to map “caramel” to “vanilla”. Of course, you write the entire new set of values with the new key and your initWithCoder: method should prefer to use the new key if available.

In some cases it may also be useful to build in fallback handling. Fallback handling is useful when one of a set of possible keys for a value is encoded. The set of supported keys may evolve over time, with newer keys being preferred in future versions of your class. Fallback handling defines a fundamental key that must be readable forever, but is used only when no other recognized keys are present. Future versions can then write a value using both a new key and the fallback key. Older versions of the class will not see the new key, but can still read the value with the fallback key.

Consider as an example a class named Image that represents images. (This example does not necessarily reflect the actual behavior of any image class, like NSImage.) Suppose the Image class is able to encode its instances as an URL, JPEG, or GIF, depending on whichever is most convenient for the particular instance. An encoded Image object, therefore, contains only one of the following keys: @"URL", @"JPEG", @"GIF". The initWithCoder: method checks for the keys in the order @"URL", @"JPEG", @"GIF", and initializes itself with the first representation that it finds. In the future it might be that none of these are easy or convenient to archive (for example, taking whatever data the Image instance does have and converting it to JPEG might be fairly expensive).

An example of fallback handling in this case would be to allow for an additional key (or group of keys), like @"rawdata", that is understood and used by Image’s initWithCoder: method if none of the other keys for this value (the image data) are present. The value of the @"rawdata" key might be defined, for example, to be an NSData object containing 32-bit RGBA pixels. There might also be auxiliary keys like @"pixelshigh" and @"pixelswide" that initWithCoder: would look for to get a minimal set of information needed to produce an Image instance from the archived information. In the future, the encoding process for an Image might write out the convenient information, whatever that is at that time, and would also have to write out the @"rawdata" and other keys to allow old decoders to read the object.


